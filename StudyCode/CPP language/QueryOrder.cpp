#include <stdio.h>  
#include <iostream>
#include <process.h>

#include <set>
#include <vector>
#include <algorithm>

using namespace std;

struct result
{
	int money;
	int index;
	result(int m, int i)
	{
		money = m;
		index = i;
	}
};

vector<int> s_vctOrder;
vector<int> s_vctMoney;
vector<result> s_vctResult;
vector<vector<result>> s_ResultAll;

void InputData()
{
	// 优化加速
	s_vctResult.reserve(10);
	s_ResultAll.reserve(100);

	// 获取数据
	//s_vctOrder = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	s_vctOrder = { 7048, 27295, 49872, 67612, 75516, 76432, 78516, 80458, 81656, 84515, 92128, 93500, 94260, 94326, 94395, 94990, 95284, 98316, 103024, 104236, 110610, 113044, 115160, 119105, 119980, 122895, 124404, 128049, 128215, 130295, 130508, 133880, 137160, 140700, 142140, 143360, 145802, 146909, 148760, 148820, 149429, 151256, 152792, 153960, 154580, 154976, 156596, 156705, 157177, 157589, 157920, 158388, 160116, 161305, 162034, 164652, 166505, 167350, 167486, 168015, 168205, 168460, 169290, 170415, 170496, 174130, 174246, 175172, 175875, 176148, 176972, 177675, 178444, 181045, 181480, 181502, 182176, 183420, 184376, 184658, 184868, 185950, 186094, 186840, 189070, 190220, 195745, 196002, 196960, 197110, 197400, 198944, 200145, 200176, 202580, 205395, 206028, 209976, 210005, 210064, 210575, 212204, 214692, 214820, 215326, 215972, 216565, 217125, 218489, 218816, 219856, 220486, 221768, 222576, 223055, 223532, 223854, 223932, 224700, 226052, 226400, 226752, 226892, 227156, 227305, 228380, 228983, 229275, 229905, 229968, 230020, 230060, 230160, 230200, 230252, 230466, 230872, 231200, 231280, 231800, 232120, 233138, 234840, 235648, 236675, 237504, 237775, 238352, 238925, 239307, 239552, 239740, 240254, 243460, 246200, 248680, 249134, 253032, 258877, 261607, 261905, 262649, 263636, 264150, 264968, 265255, 265567, 268365, 269965, 271645, 278533, 279415, 280875, 281620, 281845, 281918, 282828, 283105, 283615, 283680, 284832, 285897, 287460, 287700, 287750, 287802, 288295, 288590, 289903, 290150, 291461, 292128, 293376, 295564, 296880, 297139, 297698, 297940, 302399, 304272, 304696, 305494, 311528, 312352, 316290, 316620, 324648, 326216, 328558, 328688, 329356, 329414, 329545, 329589, 337956, 339780, 347816, 351269, 353720, 363384, 363469, 372665, 374331, 375046, 376432, 380870, 383503, 385817, 387596, 387613, 388760, 388814, 389253, 389752, 389792, 391144, 391552, 393410, 393452, 393584, 393704, 396263, 396452, 396615, 398818, 398992, 399080, 399752, 403851, 404272, 404732, 404986, 405385, 405532, 405964, 406222, 407156, 408580, 411098, 411336, 413754, 418403, 419077, 422520, 422854, 423094, 423402, 423758, 423768, 430200, 430975, 432594, 433500, 433746, 437701, 439194, 440470, 443046, 444493, 447593, 448264, 450826, 451384, 455719, 456116, 459757, 460316, 460494, 460576, 462388, 463181, 464204, 465260, 465292, 470230, 470468, 470472, 471736, 473354, 477252, 478036, 478079, 480023, 482255, 484279, 484665, 486421, 486988, 487190, 488312, 489405, 489908, 490955, 492158, 493701, 495125, 496654, 496704, 497030, 497199, 499021, 499203, 500078, 501200, 501274, 503240, 503844, 504020, 506357, 506685, 507350, 508739, 509675, 510118, 510812, 512868, 513120, 514480, 514493, 516891, 517316, 517689, 519852, 521240, 522725, 523000, 523416, 525098, 527767, 527912, 529228, 531559, 531709, 531916, 535869, 538485, 545784, 545792, 550380, 551811, 555114, 555758, 557596, 560315, 561260, 561307, 563247, 569666, 573016, 573459, 573512, 573592, 575395, 575720, 577049, 580255, 584875, 585084, 585816, 587361, 587844, 588090, 588544, 588927, 589878, 589910, 591746, 595222, 600340, 605770, 607552, 610390, 616548, 617938, 620173, 621838, 623103, 626378, 626436, 629050, 631239, 631632, 634223, 637763, 637931, 638651, 638950, 640340, 640710, 643930, 648250, 650143, 651015, 651375, 657084, 658813, 662396, 662844, 666456, 667695, 669432, 670894, 671050, 671104, 675003, 682367, 682780, 683872, 688428, 689668, 691824, 693028, 693448, 694754, 695626, 696584, 697089, 701575, 702303, 702565, 704676, 711515, 712854, 716990, 723862, 725801, 735476, 758016, 760790, 760904, 772313, 773514, 796676, 810034, 815951, 822457, 822978, 844319, 854840, 859075, 861063, 864136, 871032, 872305, 881040, 881664, 899108, 3037269, 3056933, 3510570, 3519020, 3583939, 3729252, 3747950, 3902923, 3905830, 3927072, 3954361, 4014727, 4065136, 4079505, 4080474, 4094349, 4097520, 4115468, 4231387, 4234694, 4271649, 4388212, 4419902, 4575595, 4604537, 4615609, 4702510, 4713977, 4743742, 4795797, 4883648, 4889118, 4890456, 4944121, 4949688, 5076432, 5077659, 5078221, 5157343, 5160699, 5177633, 5188551, 5298600, 5328690, 5342553, 5386158, 5778139, 5878137, 5903920, 6089077, 6214004, 6409968, 6494061, 7332354 };
}

void InputMoney()
{
	s_vctMoney = {614244, 576496, 789450, 304696, 958933, 7050, 621838, 604330, 713002, 157177, 1771230, 372665, 940796, 579708, 1287024, 304696, 1595252, 1138836, 868484, 215972, 1528858, 1037715, 423768, 304696, 1117937, 12917214, 1037670, 1970507, 530404, 450956, 749293, 657084, 3844040, 3653975, 304696, 5250263, 6409968, 3255636, 27275442, 7598213, 5881205, 591746, 5244235, 1992094, 184658, 5397857, 2654903, 6089077, 4046620, 2096047, 2436816, 15215828, 640340, 2249588, 11810712, 5234989, 4234694, 3146335, 4327772, 3182538, 230252, 1932065, 4944121, 626378, 4079505, 227156, 3311460, 2662448, 5078221, 9449855, 1445155, 9720004, 1384340, 232120, 400580, 3158147, 5896602, 423094, 3604965, 3377722, 1606289, 170496, 6581396, 175172, 3510570, 3215957, 4065136, 3510570, 2492795, 5039587, 7723149, 75516, 3510570, 3885774, 230492, 4388212, 11856609, 701377, 226892, 2311556, 607552, 2403481, 7898782, 2356626, 5376062, 3004386, 4419902, 651015, 4465741, 3729252, 3137428, 3927072, 3364094, 4034308, 585084, 5179938, 4889808, 3021094, 12419956, 3014453, 12809879, 3470283, 4883648, 6293859, 2096228, 387596, 465260, 10038405, 5177633, 5333245, 93500, 6199776, 5917119, 660676, 2179986, 5160699, 2411894, 6406671, 1294377, 6489672, 6690441, 7359543, 6059464, 3583939, 7332354};
}

// 寻找某数在集合内 找到true  返回下标. 全部大于返回-1
bool FindSingle(int money, int MaxIndex, int& pos)
{
	pos = -1;
	for (int i = 0; i < MaxIndex; ++i)
	{
		// 每次大于记录下标
		int order = s_vctOrder[i];
		if (money > order)
		{
			pos = i;
		}

		if (money == order)
		{
			pos = i;
			return true;
		}
	}

	return false;
}

// 递归变量
static result m_last_result(0,0);
static bool m_bFind;
static int m_pos;
static double m_count = 0;

// 递归查找结果
bool FindSets(int money, int endIndex)
{
	// 太深就不查找了 1000W层
	if (++m_count > 10000000)
	{
		return false;
	}

	// 查找数据
	m_pos = -1;
	m_bFind = FindSingle(money, endIndex, m_pos);

	// 找到最优解-在内部找到了.
	if (m_bFind)
	{
		s_vctResult.push_back(result(money, m_pos));
		return true;
	}
	else
	{
		// 集合内全部为大于,需要回归上一层
		if (m_pos == -1)
		{
			if (s_vctResult.empty())
			{
				return false;
			}

			// 记录尾因子
			m_last_result = s_vctResult.back();

			// 判断无解 第一个因子已经达到首位置
			if (s_vctResult.size() <= 1 && m_last_result.index <= 0)
			{
				return false;
			}
			else
			{
				// 弹出尾因子
				s_vctResult.pop_back();

				// 在更小的内部查找上次的结果
				return FindSets(money + m_last_result.money, m_last_result.index - 1);
			}
		}
		else
		{
			// 先记录因子 后扣除后继续在子集查找
			s_vctResult.push_back(result(s_vctOrder[m_pos], m_pos));
			return FindSets(money - s_vctOrder[m_pos], m_pos);
		}
	}
}

void OneNum(int money)
{
	m_count = 0;
	s_vctResult.clear();
	s_ResultAll.clear();

	// 查找数据-首次加速
	int pos = -1;
	m_bFind = FindSingle(money, s_vctOrder.size(), pos);
	if (m_bFind)
	{
		cout << "有相等订单  ";
		s_vctResult.push_back(result(s_vctOrder[pos], pos));
		s_ResultAll.push_back(s_vctResult);
		return;
	}

	if (pos < 0)
	{
		cout << "NO ANSWER";
		return;
	}

	// 第一个因子不重复循环
	for (int i = pos; i >= 0; i--)
	{
		s_vctResult.clear();

		if (FindSets(money, i))
		{
			s_ResultAll.push_back(s_vctResult);

			i = s_vctResult[0].index + 1;
		}
	}

}

// 开始计算
void QueryOrder()
{
	InputData();
	InputMoney();

	// 标准 C I/O 
	fstream out;
	out.open("Output.txt", ios::in | ios::out | ios::trunc);
	out << "This is result.\n";

	for (auto num:s_vctMoney)
	{
		OneNum(num);
		cout << num << "  匹配方式的个数为: " << s_ResultAll.size() << endl;


		out << "=====金额: " << num << "找到结果个数为: " << s_ResultAll.size() << endl;
		for (auto& single:s_ResultAll)
		{
			out << "( ";
			int temp = 0;
			for (auto& data : single)
			{
				out << data.money << " ";
				temp += data.money;
			}
			out << "=" << temp <<")";
			out << endl;
		}
		out << endl;
	}

	out.close();
}



